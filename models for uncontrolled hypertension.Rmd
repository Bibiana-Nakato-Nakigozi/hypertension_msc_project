---
title: "uncontrolled"
author: "Bibiana Nakato Nakigozi"
date: "2024-11-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r}
# Loading the necessary libraries
library(readxl)
library(dplyr)
library(writexl)
library(randomForest)
library(caret)
library(pROC)
library(xgboost)
library(Matrix)
library(rpart)
library(rpart.plot)
```

```{r}
# Loading the data sets
hypertension_withundiagnosed <- read_excel("C:/Users/bibia/OneDrive/Masters Personal Project/dummy_datasets.xlsx", sheet = 1)
hypertension_woutundiagnosed <- read_excel("C:/Users/bibia/OneDrive/Masters Personal Project/dummy_datasets.xlsx", sheet = 2)
hypertension_withuncontrolled <- read_excel("C:/Users/bibia/OneDrive/Masters Personal Project/dummy_datasets.xlsx", sheet = 3)
hypertension_woutuncontrolled <- read_excel("C:/Users/bibia/OneDrive/Masters Personal Project/dummy_datasets.xlsx", sheet = 4)

# Adding the hypertension_type column to each data set
hypertension_withundiagnosed <- hypertension_withundiagnosed %>%
  mutate(hypertension_type = 1)

hypertension_woutundiagnosed <- hypertension_woutundiagnosed %>%
  mutate(hypertension_type = 2)

hypertension_withuncontrolled <- hypertension_withuncontrolled %>%
  mutate(hypertension_type = 3)

hypertension_woutuncontrolled <- hypertension_woutuncontrolled %>%
  mutate(hypertension_type = 4)

# Combining the undiagnosed hypertension datasets
combined_undiagnosed <- bind_rows(hypertension_withundiagnosed, hypertension_woutundiagnosed)

# Combining the uncontrolled hypertension datasets
combined_uncontrolled <- bind_rows(hypertension_withuncontrolled, hypertension_woutuncontrolled)

# Saving the combined datasets to a new Excel file
write_xlsx(list(Combined_Undiagnosed = combined_undiagnosed, 
                Combined_Uncontrolled = combined_uncontrolled), 
           "C:/Users/bibia/OneDrive/Masters Personal Project/combined_hypertension_data.xlsx")
```

```{r}
#CHANGING THE UNCONTROLLED HYPERTENSION DATASET INTO NUMERIC


# Defining weights ensuring higher numbers represent better outcomes for those categories that need to be 
weights <- list(
  AgeGroup = c("16-24 years" = 7, "25-34 years" = 6, "35-44 years" = 5, "45-54 years" = 4, "55-64 years" = 3, "65-74 years" = 2, "75 years and over" = 1),
  SelfReportedHealth = c("Very good or good" = 3, "Fair" = 2, "Bad or very bad" = 1),
  BMI = c("Not overweight" = 3, "Overweight" = 2, "Obese" = 1),
  Region = c("North East" = 9, "North West" = 8, "South East" = 7, "South West" = 6, "East Midlands" = 5, "West Midlands" = 4, "Yorkshire and the Humber" = 3, "East England" = 2, "London" = 1),
  RuralUrban = c("Urban" = 2, "Rural" = 1),
  RelationshipStatus = c("Single" = 1, "Married or civil partnership" = 5, "Cohabiting" = 4, "Separated or divorced" = 2, "Widowed or surviving partner" = 3),
  Education = c("Degree or equivalent qualification" = 3, "Below degree qualification" = 2, "No qualification" = 1),
  Ethnicity = c("White" = 4, "Black" = 3, "Asian" = 2, "Other" = 1),
  SocioeconomicStatus = c("Managerial and professional occupations" = 5, "Intermediate occupations" = 4, "Small employers and own account workers" = 3, "Lower supervisory and technical occupations" = 2, "Semi-routine occupations" = 1, "Other" = 0),
  SmokingStatus = c("Never regular cigarette smoker" = 3, "Ex-regular cigarette smoker" = 2, "Current cigarette smoker" = 1),
  AlcoholConsumption = c("Not at all in last 12 months/Non-drinker" = 8, "Once or twice a year" = 7, "Once every couple of months" = 6, "Once or twice a month" = 5, "Once or twice a week" = 4, "3 or 4 days a week" = 3, "5 or 6 days a week" = 2, "Almost every day" = 1),
  AttitudeNHS = c("Very satisfied" = 5, "Quite satisfied" = 4, "Neither satisfied or dissatisfied" = 3, "Quite dissatisfied" = 2, "Very dissatisfied" = 1)
)

# Applying weights to convert categorical variables into intergers
numeric_controlled <- combined_uncontrolled %>%
  mutate(
    AgeGroup = recode(AgeGroup, !!!weights$AgeGroup),
    SelfReportedHealth = recode(SelfReportedHealth, !!!weights$SelfReportedHealth),
    BMI = recode(BMI, !!!weights$BMI),
    Region = recode(Region, !!!weights$Region),
    RuralUrban = recode(RuralUrban, !!!weights$RuralUrban),
    RelationshipStatus = recode(RelationshipStatus, !!!weights$RelationshipStatus),
    Education = recode(Education, !!!weights$Education),
    Ethnicity = recode(Ethnicity, !!!weights$Ethnicity),
    SocioeconomicStatus = recode(SocioeconomicStatus, !!!weights$SocioeconomicStatus),
    SmokingStatus = recode(SmokingStatus, !!!weights$SmokingStatus),
    AlcoholConsumption = recode(AlcoholConsumption, !!!weights$AlcoholConsumption),
    AttitudeNHS = recode(AttitudeNHS, !!!weights$AttitudeNHS)
  )

str(numeric_controlled)
head(numeric_controlled)
nrow(numeric_controlled)

```

```{r}

#PREDICTING THE LIKELIHOOD OF UNCONTROLLLED HYPERTENSION
#FEATURE IMPORTANCE

# Ensuring categorical variables are treated as factors
categorical_vars <- c("AgeGroup", "SmokingStatus", "AlcoholConsumption", "SelfReportedHealth", 
                      "Region", "RuralUrban", "Education", "Ethnicity", "AttitudeNHS", 
                      "SocioeconomicStatus", "BMI", "RelationshipStatus")
combined_uncontrolled[categorical_vars] <- lapply(combined_uncontrolled[categorical_vars], as.factor)

# Converting hypertension_type to a binary factor 3 is with uncontro
combined_uncontrolled$hypertension_type <- as.factor(ifelse(combined_uncontrolled$hypertension_type == 3, 1, 0))
print("Class distribution in Hypertension type")
print(table(combined_uncontrolled$hypertension_type))

# Splitting data into training and testing sets
set.seed(123)
train_index <- createDataPartition(combined_uncontrolled$hypertension_type, p = 0.8, list = FALSE)
train_data <- combined_uncontrolled[train_index, ]
test_data <- combined_uncontrolled[-train_index, ]

print("Class distribution in training set:")
print(table(train_data$hypertension_type))
print("Class distribution in testing set:")
print(table(test_data$hypertension_type))

# Setting up cross-validation folds
set.seed(123)
cv_folds <- createFolds(combined_uncontrolled$hypertension_type, k = 5, list = TRUE, returnTrain = FALSE)

# Initializing vectors to store cross-validation metrics
cv_accuracy <- numeric(5)
cv_sensitivity <- numeric(5)
cv_specificity <- numeric(5)
cv_auc <- numeric(5)

# Performing a 5-fold cross-validation
for (i in 1:5) {
  # Splitting data into training and validation sets
  train_data2 <- combined_uncontrolled[-cv_folds[[i]], ]
  valid_data <- combined_uncontrolled[cv_folds[[i]], ]
  
  # Building the Random Forest model
  rf_model <- randomForest(hypertension_type ~ AgeGroup + BMI + SmokingStatus + AlcoholConsumption + 
                           SelfReportedHealth + Region + RuralUrban + Education + 
                           Ethnicity + SocioeconomicStatus + AttitudeNHS, 
                           data = train_data2, 
                           importance = TRUE, 
                           ntree = 500)
  
  # feature importance
  importance_values <- importance(rf_model)
  print(paste("Feature importance values for fold", i, ":"))
  print(importance_values)
  
  # plot feature importance
  varImpPlot(rf_model, main = paste("Variable Importance Plot - Fold", i))
  
  # predictions on the validation set
  predictions <- predict(rf_model, newdata = valid_data, type = "prob")[, 2]
  
  # Calculating ROC curve and AUC
  roc_curve <- roc(as.numeric(as.character(valid_data$hypertension_type)), predictions)
  auc_value <- auc(roc_curve)
  cv_auc[i] <- auc_value
  
  # Plotting ROC curve
  plot(roc_curve, main = paste("ROC Curve (Fold", i, "AUC =", round(auc_value, 3), ")"))
  
  # Confusion Matrix
  conf_matrix <- confusionMatrix(predict(rf_model, newdata = valid_data), valid_data$hypertension_type)
  print(paste("Confusion Matrix for fold", i, ":"))
  print(conf_matrix)
  
  # Store metrics
  cv_accuracy[i] <- conf_matrix$overall["Accuracy"]
  cv_sensitivity[i] <- conf_matrix$byClass["Sensitivity"]
  cv_specificity[i] <- conf_matrix$byClass["Specificity"]
}

# Calculating average performance metrics across folds
cat("\n--- Cross-Validation Results ---\n")
cat("Average AUC:", mean(cv_auc), "\n")
cat("Average Accuracy:", mean(cv_accuracy), "\n")
cat("Average Sensitivity:", mean(cv_sensitivity), "\n")
cat("Average Specificity:", mean(cv_specificity), "\n")

# Building the final Random Forest model on the entire training dataset
final_rf_model <- randomForest(hypertension_type ~ AgeGroup + BMI + SmokingStatus + AlcoholConsumption + 
                               SelfReportedHealth + Region + RuralUrban + Education + 
                               Ethnicity + SocioeconomicStatus + AttitudeNHS, 
                               data = train_data2, 
                               importance = TRUE, 
                               ntree = 500)

# Displaying final feature importance
final_importance_values <- importance(final_rf_model)
print("Final Feature Importance:")
print(final_importance_values)

# Visualizing final feature importance
varImpPlot(final_rf_model, main = "Final Variable Importance Plot")

# Testing the model on the independent test set
final_predictions <- predict(final_rf_model, newdata = test_data, type = "prob")[, 2]

# Calculating ROC curve and AUC for test set
test_roc_curve <- roc(as.numeric(as.character(test_data$hypertension_type)), final_predictions)
test_auc_value <- auc(test_roc_curve)

# Plotting ROC curve for test set
plot(test_roc_curve, main = paste("Test ROC Curve (AUC =", round(test_auc_value, 3), ")"))

# Generate Confusion Matrix for the test set
test_conf_matrix <- confusionMatrix(predict(final_rf_model, newdata = test_data), test_data$hypertension_type)
print("Test Set Confusion Matrix:")
print(test_conf_matrix)

# Calculating and displaying final performance metrics
test_sensitivity <- test_conf_matrix$byClass["Sensitivity"]
test_specificity <- test_conf_matrix$byClass["Specificity"]

```

```{r}

#XGBOOST

# Ensuring the outcome variable is binary
numeric_controlled$hypertension_type <- factor(ifelse(numeric_controlled$hypertension_type == 3, 1, 0))

# Removing rows with NA values only in the outcome variable
numeric_controlled <- numeric_controlled[!is.na(numeric_controlled$hypertension_type), ]

# Removing the `id` column to prevent it from being included in the model
numeric_controlled <- numeric_controlled[, !names(numeric_controlled) %in% "id"]

# Converting categorical variables to one-hot encoding (dummy variables)
dummies <- dummyVars(~ AgeGroup + SmokingStatus + AlcoholConsumption +
                     SelfReportedHealth + Region + RuralUrban +
                     Education + Ethnicity + AttitudeNHS,
                     data = numeric_controlled)

numeric_controlled_dummies <- predict(dummies, newdata = numeric_controlled)

# Combining dummy variables with numeric predictors
numeric_controlled <- cbind(
  numeric_controlled[, !names(numeric_controlled) %in% c("AgeGroup", "SmokingStatus",
                                                       "AlcoholConsumption", "SelfReportedHealth",
                                                       "Region", "RuralUrban", "Education",
                                                       "Ethnicity", "AttitudeNHS")],
  numeric_controlled_dummies
)

# Converting outcome variable to numeric for XGBoost
numeric_controlled$hypertension_type <- as.numeric(as.character(numeric_controlled$hypertension_type))

# Splitting the data into training and testing sets
set.seed(123)
train_index <- createDataPartition(numeric_controlled$hypertension_type, p = 0.8, list = FALSE)
train_data <- numeric_controlled[train_index, ]
test_data <- numeric_controlled[-train_index, ]

# Preparing data for XGBoost
train_matrix <- xgb.DMatrix(data = as.matrix(train_data[, -which(names(train_data) == "hypertension_type")]),
                             label = train_data$hypertension_type)
test_matrix <- xgb.DMatrix(data = as.matrix(test_data[, -which(names(test_data) == "hypertension_type")]),
                            label = test_data$hypertension_type)

# Defining parameters for XGBoost
params <- list(
  objective = "binary:logistic",
  eval_metric = "auc",
  max_depth = 4,           
  eta = 0.05,              
  gamma = 5,               
  subsample = 0.8,         
  colsample_bytree = 0.8,  
  scale_pos_weight = 5     
)

# Performing 5-fold Cross-Validation to determine optimal boosting rounds
cv_results <- xgb.cv(
  params = params,
  data = train_matrix,
  nfold = 5,
  nrounds = 100,
  early_stopping_rounds = 10,
  verbose = 1,
  metrics = "auc"
)

# Displaying the best iteration and AUC
best_nrounds <- cv_results$best_iteration
cat("Best iteration from CV:", best_nrounds, "\n")
cat("Best AUC from CV:", max(cv_results$evaluation_log$test_auc_mean), "\n")

# Training the final model using the optimal number of boosting rounds
xgb_model <- xgb.train(
  params = params,
  data = train_matrix,
  nrounds = best_nrounds,
  watchlist = list(train = train_matrix, test = test_matrix),
  early_stopping_rounds = 10,
  verbose = 0
)


# Setting up k-fold cross-validation
set.seed(123)
k <- 5  
folds <- createFolds(numeric_controlled$hypertension_type, k = k)

# Initializing vectors to store cross-validation results
cv_auc <- numeric(k)
cv_accuracy <- numeric(k)
cv_sensitivity <- numeric(k)
cv_specificity <- numeric(k)

# Performing k-fold cross-validation
for (i in seq_along(folds)) {
  # Splitting data into training and validation sets
  train_indices <- setdiff(seq_len(nrow(numeric_controlled)), folds[[i]])
  train_data_cv <- numeric_controlled[train_indices, ]
  valid_data_cv <- numeric_controlled[folds[[i]], ]

  # Preparing training and validation matrices for XGBoost
  train_matrix_cv <- xgb.DMatrix(data = as.matrix(train_data_cv[, -which(names(train_data_cv) == "hypertension_type")]),
                                  label = train_data_cv$hypertension_type)
  valid_matrix_cv <- xgb.DMatrix(data = as.matrix(valid_data_cv[, -which(names(valid_data_cv) == "hypertension_type")]),
                                  label = valid_data_cv$hypertension_type)

  # Training the XGBoost model
  cv_model <- xgb.train(
    params = params,
    data = train_matrix_cv,
    nrounds = best_nrounds,  
    watchlist = list(train = train_matrix_cv, valid = valid_matrix_cv),
    verbose = 0
  )

  #  prediction on the validation set
  valid_predictions_cv <- predict(cv_model, valid_matrix_cv)
  valid_predicted_classes_cv <- ifelse(valid_predictions_cv > 0.5, 1, 0)

  # Evaluating performance metrics
  conf_matrix_cv <- confusionMatrix(
    factor(valid_predicted_classes_cv),
    factor(valid_data_cv$hypertension_type)
  )

  # Calculating the ROC and AUC
  roc_curve_cv <- roc(valid_data_cv$hypertension_type, valid_predictions_cv)
  auc_value_cv <- auc(roc_curve_cv)

  # Store metrics
  cv_auc[i] <- auc_value_cv
  cv_accuracy[i] <- conf_matrix_cv$overall["Accuracy"]
  cv_sensitivity[i] <- conf_matrix_cv$byClass["Sensitivity"]
  cv_specificity[i] <- conf_matrix_cv$byClass["Specificity"]

  # Plotting the ROC curve for each fold
  plot(roc_curve_cv, main = paste("ROC Curve (Fold", i, "AUC =", round(auc_value_cv, 3), ")"))
}

#  average performance across folds
cat("\n--- Cross-Validation Results ---\n")
cat("Average AUC:", mean(cv_auc), "\n")
cat("Average Accuracy:", mean(cv_accuracy), "\n")
cat("Average Sensitivity:", mean(cv_sensitivity), "\n")
cat("Average Specificity:", mean(cv_specificity), "\n")

# Final Model Evaluation on Test Set
final_predictions <- predict(xgb_model, test_matrix)
final_predicted_classes <- ifelse(final_predictions > 0.5, 1, 0)

# Confusion matrix
final_conf_matrix <- confusionMatrix(factor(final_predicted_classes), factor(test_data$hypertension_type))
print(final_conf_matrix)

# ROC curve and AUC for test set
final_roc_curve <- roc(test_data$hypertension_type, final_predictions)
final_auc_value <- auc(final_roc_curve)

# Plotting ROC curve for test set
plot(final_roc_curve, main = paste("Test ROC Curve (AUC =", round(final_auc_value, 3), ")"))

# Displaying final test set performance metrics
cat("\n--- Final Model Performance on Test Set ---\n")
cat("Test Sensitivity:", final_conf_matrix$byClass["Sensitivity"], "\n")
cat("Test Specificity:", final_conf_matrix$byClass["Specificity"], "\n")
cat("Test AUC:", final_auc_value, "\n")
```

```{r}
# Loading necessary libraries
library(caret)
library(rpart)
library(rpart.plot)
library(pROC)

# Preparing the UncontrolledHypertension variable as a factor
numeric_controlled$hypertension_type <- ifelse(numeric_controlled$hypertension_type == 3, 1, 0)
numeric_controlled$hypertension_type <- as.factor(numeric_controlled$hypertension_type)

# Checking class distribution
print("Class distribution in UncontrolledHypertension:")
print(table(numeric_controlled$hypertension_type))

# Defining categorical variables
categorical_vars <- c("AgeGroup", "SmokingStatus", "AlcoholConsumption", "SelfReportedHealth", 
                      "Region", "RuralUrban", "Education", "Ethnicity", "AttitudeNHS", 
                      "SocioeconomicStatus")

# Ensuring categorical variables are treated as factors
numeric_controlled[categorical_vars] <- lapply(numeric_controlled[categorical_vars], as.factor)


# Setting up k-fold cross-validation
set.seed(123)
cv_folds <- createFolds(numeric_controlled$hypertension_type, k = 10, list = TRUE)

# Initializing vectors to store metrics for cross-validation
cv_accuracy <- numeric(10)
cv_sensitivity <- numeric(10)
cv_specificity <- numeric(10)
cv_auc <- numeric(10)

# Performing 10-fold cross-validation
for (i in 1:10) {
  # Split data into training and validation sets for this fold
  train_data2 <- numeric_controlled[-cv_folds[[i]], ]
  valid_data <- numeric_controlled[cv_folds[[i]], ]
  
  # Building the Decision Tree model
  dt_model <- rpart(hypertension_type ~ AgeGroup + BMI + SmokingStatus + AlcoholConsumption + 
                    SelfReportedHealth + Region + RuralUrban + Education + 
                    Ethnicity + SocioeconomicStatus + AttitudeNHS, 
                    data = train_data2, 
                    method = "class")
  
  #  predictions on the validation set
  predictions <- predict(dt_model, newdata = valid_data, type = "class")
  
  # Evaluating model performance using confusion matrix
  conf_matrix <- confusionMatrix(predictions, valid_data$hypertension_type)
  
  # Storing metrics for this fold
  cv_accuracy[i] <- conf_matrix$overall["Accuracy"]
  cv_sensitivity[i] <- conf_matrix$byClass["Sensitivity"]
  cv_specificity[i] <- conf_matrix$byClass["Specificity"]
  
  # Calculating AUC and ROC curve
  predicted_probs <- predict(dt_model, newdata = valid_data, type = "prob")[, 2]
  roc_curve <- roc(valid_data$hypertension_type, predicted_probs)
  cv_auc[i] <- auc(roc_curve)
  
  # Plotting ROC curve for this fold
  plot(roc_curve, main = paste("ROC Curve (Fold", i, "AUC =", round(cv_auc[i], 3), ")"))
}

# Calculating and printing average metrics across all folds
cat("\n--- Cross-Validation Results ---\n")
cat("Average Accuracy:", mean(cv_accuracy), "\n")
cat("Average Sensitivity:", mean(cv_sensitivity), "\n")
cat("Average Specificity:", mean(cv_specificity), "\n")
cat("Average AUC:", mean(cv_auc), "\n")

# Final Decision Tree model on the entire dataset (training data)
final_dt_model <- rpart(hypertension_type ~ AgeGroup + BMI + SmokingStatus + AlcoholConsumption + 
                        SelfReportedHealth + Region + RuralUrban + Education + 
                        Ethnicity + SocioeconomicStatus + AttitudeNHS, 
                        data = numeric_controlled, 
                        method = "class")

# Visualizing the final Decision Tree
rpart.plot(final_dt_model, type = 1, extra = 1, main = "Final Decision Tree for Uncontrolled Hypertension")

# Evaluating on the test set 
set.seed(123)
train_index <- createDataPartition(numeric_controlled$hypertension_type, p = 0.8, list = FALSE)
train_data <- numeric_controlled[train_index, ]
test_data <- numeric_controlled[-train_index, ]

# Making final predictions on the test set
final_predictions <- predict(final_dt_model, newdata = test_data, type = "class")

# Confusion Matrix for the test set
test_conf_matrix <- confusionMatrix(final_predictions, test_data$hypertension_type)
print("Final Test Set Confusion Matrix:")
print(test_conf_matrix)

# Calculating AUC for the final model
final_predicted_probs <- predict(final_dt_model, newdata = test_data, type = "prob")[, 2]
test_roc_curve <- roc(test_data$hypertension_type, final_predicted_probs)
test_auc_value <- auc(test_roc_curve)

# Plotting final ROC curve for the test set
plot(test_roc_curve, main = paste("Final Test ROC Curve (AUC =", round(test_auc_value, 3), ")"))

# final performance metrics
final_sensitivity <- test_conf_matrix$byClass["Sensitivity"]
final_specificity <- test_conf_matrix$byClass["Specificity"]
final_ppv <- test_conf_matrix$byClass["Pos Pred Value"]
final_npv <- test_conf_matrix$byClass["Neg Pred Value"]

cat("\nFinal Model Performance on Test Set:\n")
cat("Sensitivity:", final_sensitivity, "\n")
cat("Specificity:", final_specificity, "\n")
cat("Positive Predictive Value:", final_ppv, "\n")
cat("Negative Predictive Value:", final_npv, "\n")
cat("Test AUC:", test_auc_value, "\n")

```

```{r}
library(performance)
library(nortest)

# objective 4 - To find out how the people’s attitude towards NHS affects their health regarding to hypertension control.

# Assuming your data frame is named numeric_uncontrolled

# Converting hypertension type to a numeric variable for analysis
numeric_controlled <- numeric_controlled %>%
  mutate(hypertension_type = ifelse(hypertension_type == 3, 1, 0))  # 1 = uncontrolled, 0 = controlled

# Checking the structure of your data
str(numeric_controlled)

# Fitting the linear regression model

model1 <- lm(numeric_controlled$hypertension_type~numeric_controlled$AttitudeNHS)  


# Summary of the regression model
summary(model1)

#checking the model
check_model(model1)

#normality test on the residuals

residuals_data <- residuals(model1)

ad.test(residuals_data)


```

```{r}
# objective 5 - to examine how socioeconomic status, smoking, alcohol consumption and people’s attitude towards NHS affect hypertension prevalence and management.

# Fitting the regression model
multiple_linear_model <- lm(numeric_controlled$hypertension_type ~ SocioeconomicStatus + SmokingStatus + 
                             AlcoholConsumption + AttitudeNHS, 
                             data = numeric_controlled)

# Summary of the regression model
summary(multiple_linear_model)

#checking the model
check_model(multiple_linear_model)

#normality test on the residuals

residuals_data <- residuals(multiple_linear_model)
shapiro.test(residuals_data)
```

