---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

```{r}
# Loading the necessary libraries
library(readxl)
library(dplyr)
library(writexl)
library(randomForest)
library(caret)
library(pROC)
library(xgboost)
library(Matrix)
library(rpart)
library(rpart.plot)
```

```{r}
# Loading the data sets
hypertension_withundiagnosed <- read_excel("C:/Users/bibia/OneDrive/Masters Personal Project/dummy_datasets.xlsx", sheet = 1)
hypertension_woutundiagnosed <- read_excel("C:/Users/bibia/OneDrive/Masters Personal Project/dummy_datasets.xlsx", sheet = 2)
hypertension_withuncontrolled <- read_excel("C:/Users/bibia/OneDrive/Masters Personal Project/dummy_datasets.xlsx", sheet = 3)
hypertension_woutuncontrolled <- read_excel("C:/Users/bibia/OneDrive/Masters Personal Project/dummy_datasets.xlsx", sheet = 4)

# Adding the hypertension_type column to each data set
hypertension_withundiagnosed <- hypertension_withundiagnosed %>%
  mutate(hypertension_type = 1)

hypertension_woutundiagnosed <- hypertension_woutundiagnosed %>%
  mutate(hypertension_type = 2)

hypertension_withuncontrolled <- hypertension_withuncontrolled %>%
  mutate(hypertension_type = 3)

hypertension_woutuncontrolled <- hypertension_woutuncontrolled %>%
  mutate(hypertension_type = 4)

# Combining the undiagnosed hypertension datasets
combined_undiagnosed <- bind_rows(hypertension_withundiagnosed, hypertension_woutundiagnosed)

# Combining the uncontrolled hypertension datasets
combined_uncontrolled <- bind_rows(hypertension_withuncontrolled, hypertension_woutuncontrolled)

```

```{r}
# from the characteristics of sex from all adults
data <- data.frame(
  Sex = c(rep("Female", 7), rep("Male", 7)),
  Group = rep(c("16-24 years", "25-34 years", "35-44 years", "45-54 years", "55-64 years", "65-74 years", "75 years and over"), 2),
  UnweightedSampleSize = c(790, 1580, 1890, 2120, 2050, 2060, 1510, 650, 1020, 1380, 1520, 1730, 1840, 1350),
  WeightedSampleSize = c(1350, 1740, 1670, 1880, 1600, 1430, 1220, 1470, 1740, 1680, 1810, 1610, 1330, 960),
  Percentage = c(12, 16, 15, 17, 15, 13, 11, 14, 16, 16, 17, 15, 13, 9)
)

# Calculating the total sample size per age group
total_sample_size <- aggregate(WeightedSampleSize ~ Group, data = data, sum)

# Merging to get the total sample size back into the original data
data_with_totals <- merge(data, total_sample_size, by = "Group", suffixes = c("", "_Total"))

# Calculating the probability of being male or female for each age group
data_with_totals$Probability <- data_with_totals$WeightedSampleSize / data_with_totals$WeightedSampleSize_Total

head(data_with_totals)
print(data_with_totals)
```

```{r}
# Defining the probability of male and female per age group
age_groups <- c("16-24 years", "25-34 years", "35-44 years", "45-54 years", "55-64 years", "65-74 years", "75 years and over")

# Probabilities for each age group (these should sum to 1 for each age group)
male_probabilities <- c(0.521, 0.500, 0.501, 0.491, 0.501, 0.482, 0.440)
female_probabilities <- 1 - male_probabilities  # Female probabilities

# Assigning gender probabilities based on the age group
age_gender_data <- data.frame(
  AgeGroup = age_groups,
  MaleProb = male_probabilities,
  FemaleProb = female_probabilities
)

```

```{r}

#adding gender 
# Function to assign gender based on age group and gender probabilities
assign_gender <- function(age_group) {
  prob <- age_gender_data %>%
    filter(AgeGroup == age_group) %>%
    select(MaleProb, FemaleProb) %>%
    unlist()

  # Generating a random number between 0 and 1 and assign gender based on the probabilities
  rand_num <- runif(1)
  if (rand_num < prob["MaleProb"]) {
    return("Male")
  } else {
    return("Female")
  }
}

# Set seed for reproducibility
set.seed(123)

# function to assign gender
combined_undiagnosed$Gender <- sapply(combined_undiagnosed$AgeGroup, assign_gender)
combined_uncontrolled$Gender <- sapply(combined_uncontrolled$AgeGroup, assign_gender)

head(combined_uncontrolled)
head(combined_undiagnosed)

```

```{r}
table(combined_uncontrolled$Gender)

table(combined_undiagnosed$Gender)

```
```{r}
# Saving the combined datasets to a new Excel file
write_xlsx(list(Combined_Undiagnosed = combined_undiagnosed, 
                Combined_Uncontrolled = combined_uncontrolled), 
           "C:/Users/bibia/OneDrive/Masters Personal Project/combined_hypertension_data.xlsx")
```

```{r}
# Setting seed for reproducibility
set.seed(123)

# Sample 1990 rows from combined_undiagnosed where hypertension_type = 1 (undiagnosed)
sampled_undiagnosed <- combined_undiagnosed %>%
  filter(hypertension_type == 1) %>%
  sample_n(1990)

# Sample 1990 rows from combined_undiagnosed where hypertension_type = 2 (without undiagnosed)
sampled_woutundiagnosed <- combined_undiagnosed %>%
  filter(hypertension_type == 2) %>%
  sample_n(1990)

# Combining  the two sampled datasets into a balanced dataset
balanced_data <- bind_rows(sampled_undiagnosed, sampled_woutundiagnosed)

# Verifying the structure and counts of the balanced dataset
print(table(balanced_data$hypertension_type))  
head(balanced_data)                            
# Saving the balanced dataset to a new Excel file
write_xlsx(balanced_data, "C:/Users/bibia/OneDrive/Masters Personal Project/balanced_hypertension_data.xlsx")

```

```{r}
table(balanced_data$hypertension_type)

summary(balanced_data)


```




```{r}
# Ensuring that categorical variables are treated as factors
categorical_vars <- c("AgeGroup", "SmokingStatus", "AlcoholConsumption", "SelfReportedHealth", 
                      "Region", "RuralUrban", "Education", "Ethnicity", "AttitudeNHS", 
                      "SocioeconomicStatus", "BMI", "RelationshipStatus", "Gender")
balanced_data[categorical_vars] <- lapply(balanced_data[categorical_vars], as.factor)

# Converting the hypertension_type to a binary factor 1= with undiagnosed else is without undiagnosed hypertension
balanced_data$hypertension_type <- as.factor(ifelse(balanced_data$hypertension_type == 1, 1, 0))

# Checking class distribution
print("Class distribution in UndiagnosedHypertension:")
print(table(balanced_data$hypertension_type))

# Splitting data into training and testing sets
set.seed(123)
train_index <- createDataPartition(balanced_data$hypertension_type, p = 0.8, list = FALSE)
train_data <- balanced_data[train_index, ]
test_data <- balanced_data[-train_index, ]

# Checking class distribution in training and testing sets
print("Class distribution in training set:")
print(table(train_data$hypertension_type))
print("Class distribution in testing set:")
print(table(test_data$hypertension_type))

# Initializing a data frame to store cross-validation results
cv_results <- data.frame(
  Fold = numeric(),
  Accuracy = numeric(),
  Sensitivity = numeric(),
  Specificity = numeric(),
  AUC = numeric()
)

# Setting up cross-validation folds
set.seed(123)
cv_folds <- createFolds(balanced_data$hypertension_type, k = 6, list = TRUE, returnTrain = FALSE)

# Performing 6-fold cross-validation
for (i in 1:6) {
  # Splitting data into training and validation sets
  train_data_cv <- balanced_data[-cv_folds[[i]], ]
  valid_data_cv <- balanced_data[cv_folds[[i]], ]
  
  # Building the Random Forest model
  rf_model <- randomForest(hypertension_type ~ AgeGroup + BMI + SmokingStatus + AlcoholConsumption + 
                           SelfReportedHealth + Region + RuralUrban + Education + 
                           Ethnicity + SocioeconomicStatus + AttitudeNHS + Gender, 
                           data = train_data_cv, 
                           importance = TRUE, 
                           ntree = 500)
  
  # Displaying feature importance
  importance_values <- importance(rf_model)
  print(paste("Feature importance values for fold", i, ":"))
  print(importance_values)
  
  # Visualizing feature importance
  varImpPlot(rf_model, main = paste("Variable Importance Plot - Fold", i))
  
  # Making predictions on the validation set
  predictions <- predict(rf_model, newdata = valid_data_cv, type = "prob")[, 2]
  
  # Calculating ROC curve and AUC
  roc_curve <- roc(as.numeric(as.character(valid_data_cv$hypertension_type)), predictions)
  auc_value <- auc(roc_curve)
  
  # Plotting ROC curve
  plot(roc_curve, main = paste("ROC Curve (Fold", i, "AUC =", round(auc_value, 3), ")"))
  
  # Generating Confusion Matrix
  predicted_classes <- predict(rf_model, newdata = valid_data_cv)
  conf_matrix <- confusionMatrix(predicted_classes, valid_data_cv$hypertension_type)
  
  # Storing results in the data frame
  cv_results <- rbind(cv_results, data.frame(
    Fold = i,
    Accuracy = conf_matrix$overall["Accuracy"],
    Sensitivity = conf_matrix$byClass["Sensitivity"],
    Specificity = conf_matrix$byClass["Specificity"],
    AUC = auc_value
  ))
}

# Calculating average performance metrics across folds
cat("\n--- Cross-Validation Results ---\n")
cat("Average Accuracy:", mean(cv_results$Accuracy, na.rm = TRUE), "\n")
cat("Average Sensitivity:", mean(cv_results$Sensitivity, na.rm = TRUE), "\n")
cat("Average Specificity:", mean(cv_results$Specificity, na.rm = TRUE), "\n")
cat("Average AUC:", mean(cv_results$AUC, na.rm = TRUE), "\n")

# Printing the results table
print("Cross-Validation Results by Fold:")
print(cv_results)

# Building the final Random Forest model on the entire training dataset
final_rf_model <- randomForest(hypertension_type ~ AgeGroup + BMI + SmokingStatus + AlcoholConsumption + 
                               SelfReportedHealth + Region + RuralUrban + Education + 
                               Ethnicity + SocioeconomicStatus + AttitudeNHS + Gender, 
                               data = train_data, 
                               importance = TRUE, 
                               ntree = 500)

# Displaying the final feature importance
final_importance_values <- importance(final_rf_model)
print("Final Feature Importance:")
print(final_importance_values)

# Visualizing final feature importance
varImpPlot(final_rf_model, main = "Final Variable Importance Plot")

# Testing the model on the independent test set
final_predictions <- predict(final_rf_model, newdata = test_data, type = "prob")[, 2]

# Calculating the ROC curve and AUC for test set
test_roc_curve <- roc(as.numeric(as.character(test_data$hypertension_type)), final_predictions)
test_auc_value <- auc(test_roc_curve)

# Plotting ROC curve for test set
plot(test_roc_curve, main = paste("Test ROC Curve (AUC =", round(test_auc_value, 3), ")"))

# Confusion Matrix for the test set
test_predicted_classes <- predict(final_rf_model, newdata = test_data)
test_conf_matrix <- confusionMatrix(test_predicted_classes, test_data$hypertension_type)

# Printing test set confusion matrix and metrics
cat("\n--- Final Model Performance on Test Set ---\n")
print(test_conf_matrix)
cat("Test Sensitivity:", test_conf_matrix$byClass["Sensitivity"], "\n")
cat("Test Specificity:", test_conf_matrix$byClass["Specificity"], "\n")
cat("Test Positive Predictive Value:", test_conf_matrix$byClass["Pos Pred Value"], "\n")
cat("Test Negative Predictive Value:", test_conf_matrix$byClass["Neg Pred Value"], "\n")
cat("Test AUC:", test_auc_value, "\n")


cat("\n--- confusion matrix table for the training set ---\n")

# Printing the confusion matrix table for the training set
print(conf_matrix$table)

cat("\n--- confusion matrix table for the testing set ---\n")
# Printing the confusion matrix table for the testing set
test_conf_matrix <- confusionMatrix(test_predicted_classes, test_data$hypertension_type)
print(test_conf_matrix$table)


```


```{r}
#CHANGING THE UNDIAGONSED HYPERTENSION DATASET INTO NUMERIC

# Defining weights ensuring higher numbers represent better outcomes for those categories that need to be 
weights <- list(
  AgeGroup = c("16-24 years" = 7, "25-34 years" = 6, "35-44 years" = 5, "45-54 years" = 4, "55-64 years" = 3, "65-74 years" = 2, "75 years and over" = 1),
  SelfReportedHealth = c("Very good or good" = 3, "Fair" = 2, "Bad or very bad" = 1),
  BMI = c("Not overweight" = 3, "Overweight" = 2, "Obese" = 1),
  Region = c("North East" = 9, "North West" = 8, "South East" = 7, "South West" = 6, "East Midlands" = 5, "West Midlands" = 4, "Yorkshire and the Humber" = 3, "East England" = 2, "London" = 1),
  RuralUrban = c("Urban" = 2, "Rural" = 1),
  RelationshipStatus = c("Single" = 1, "Married or civil partnership" = 5, "Cohabiting" = 4, "Separated or divorced" = 2, "Widowed or surviving partner" = 3),
  Education = c("Degree or equivalent qualification" = 3, "Below degree qualification" = 2, "No qualification" = 1),
  Ethnicity = c("White" = 4, "Black" = 3, "Asian" = 2, "Other" = 1),
  SocioeconomicStatus = c("Managerial and professional occupations" = 5, "Intermediate occupations" = 4, "Small employers and own account workers" = 3, "Lower supervisory and technical occupations" = 2, "Semi-routine occupations" = 1, "Other" = 0),
  SmokingStatus = c("Never regular cigarette smoker" = 3, "Ex-regular cigarette smoker" = 2, "Current cigarette smoker" = 1),
  AlcoholConsumption = c("Not at all in last 12 months/Non-drinker" = 8, "Once or twice a year" = 7, "Once every couple of months" = 6, "Once or twice a month" = 5, "Once or twice a week" = 4, "3 or 4 days a week" = 3, "5 or 6 days a week" = 2, "Almost every day" = 1),
  AttitudeNHS = c("Very satisfied" = 5, "Quite satisfied" = 4, "Neither satisfied or dissatisfied" = 3, "Quite dissatisfied" = 2, "Very dissatisfied" = 1),
  Gender = c("Female" = 2, "Male" = 1)
)


# Applying weights to convert categorical variables into interger
numeric_diagnosed <- balanced_data %>%
  mutate(
    AgeGroup = recode(AgeGroup, !!!weights$AgeGroup),
    SelfReportedHealth = recode(SelfReportedHealth, !!!weights$SelfReportedHealth),
    BMI = recode(BMI, !!!weights$BMI),
    Region = recode(Region, !!!weights$Region),
    RuralUrban = recode(RuralUrban, !!!weights$RuralUrban),
    RelationshipStatus = recode(RelationshipStatus, !!!weights$RelationshipStatus),
    Education = recode(Education, !!!weights$Education),
    Ethnicity = recode(Ethnicity, !!!weights$Ethnicity),
    SocioeconomicStatus = recode(SocioeconomicStatus, !!!weights$SocioeconomicStatus),
    SmokingStatus = recode(SmokingStatus, !!!weights$SmokingStatus),
    AlcoholConsumption = recode(AlcoholConsumption, !!!weights$AlcoholConsumption),
    AttitudeNHS = recode(AttitudeNHS, !!!weights$AttitudeNHS),
    Gender = recode(Gender, !!!weights$Gender)
  )


str(numeric_diagnosed)
head(numeric_diagnosed)
nrow(numeric_diagnosed)

table(numeric_diagnosed$Education)


```


```{r}

#XGBOOST

# Ensuring the outcome variable is binary
numeric_diagnosed$hypertension_type <- factor(ifelse(numeric_diagnosed$hypertension_type == 1, 1, 0))

# Removing rows with NA values only in the outcome variable
numeric_diagnosed <- numeric_diagnosed[!is.na(numeric_diagnosed$hypertension_type), ]

# Removing the `id` column to prevent it from being included in the model
numeric_diagnosed <- numeric_diagnosed[, !names(numeric_diagnosed) %in% "id"]

# Converting categorical variables to one-hot encoding (dummy variables)
dummies <- dummyVars(~ AgeGroup + SmokingStatus + AlcoholConsumption +
                     SelfReportedHealth + Region + RuralUrban +
                     Education + Ethnicity + AttitudeNHS + Gender+ RelationshipStatus+ SocioeconomicStatus+ BMI,
                     data = numeric_diagnosed)

numeric_diagnosed_dummies <- predict(dummies, newdata = numeric_diagnosed)

# Combining dummy variables with numeric predictors
numeric_diagnosed <- cbind(
  numeric_diagnosed[, !names(numeric_diagnosed) %in% c("AgeGroup", "SmokingStatus",
                                                       "AlcoholConsumption", "SelfReportedHealth",
                                                       "Region", "RuralUrban", "Education",
                                                       "Ethnicity", "AttitudeNHS", "Gender", "RelationshipStatus", "SocioeconomicStatus", "BMI" )],
  numeric_diagnosed_dummies
)

# Converting outcome variable to numeric for XGBoost
numeric_diagnosed$hypertension_type <- as.numeric(as.character(numeric_diagnosed$hypertension_type))

# Splitting the data into training and testing sets
set.seed(123)
train_index <- createDataPartition(numeric_diagnosed$hypertension_type, p = 0.8, list = FALSE)
train_data <- numeric_diagnosed[train_index, ]
test_data <- numeric_diagnosed[-train_index, ]

# Preparing data for XGBoost
train_matrix <- xgb.DMatrix(data = as.matrix(train_data[, -which(names(train_data) == "hypertension_type")]),
                             label = train_data$hypertension_type)
test_matrix <- xgb.DMatrix(data = as.matrix(test_data[, -which(names(test_data) == "hypertension_type")]),
                            label = test_data$hypertension_type)

# Defining parameters for XGBoost
params <- list(
  objective = "binary:logistic",
  eval_metric = "auc",
  max_depth = 4,           
  eta = 0.05,              
  gamma = 5,               
  subsample = 0.8,         
  colsample_bytree = 0.8,  
  scale_pos_weight = 5     
)

# Performing 5-fold Cross-Validation to determine optimal boosting rounds
cv_results <- xgb.cv(
  params = params,
  data = train_matrix,
  nfold = 6,
  nrounds = 100,
  early_stopping_rounds = 10,
  verbose = 1,
  metrics = "auc"
)

# Displaying the best iteration and AUC
best_nrounds <- cv_results$best_iteration
cat("Best iteration from CV:", best_nrounds, "\n")
cat("Best AUC from CV:", max(cv_results$evaluation_log$test_auc_mean), "\n")

# Training the final model using the optimal number of boosting rounds
xgb_model <- xgb.train(
  params = params,
  data = train_matrix,
  nrounds = best_nrounds,
  watchlist = list(train = train_matrix, test = test_matrix),
  early_stopping_rounds = 10,
  verbose = 0
)

# Setting up a k-fold cross-validation
set.seed(123)
k <- 6  
folds <- createFolds(numeric_diagnosed$hypertension_type, k = k)

# Initializing vectors to store metrics for each fold
cv_auc <- numeric(k)
cv_accuracy <- numeric(k)
cv_sensitivity <- numeric(k)
cv_specificity <- numeric(k)

# k-fold cross-validation
for (i in seq_along(folds)) {
  # Split data into training and validation sets
  train_indices <- setdiff(seq_len(nrow(numeric_diagnosed)), folds[[i]])
  train_data_cv <- numeric_diagnosed[train_indices, ]
  valid_data_cv <- numeric_diagnosed[folds[[i]], ]

  # Preparing training and validation matrices for XGBoost
  train_matrix_cv <- xgb.DMatrix(data = as.matrix(train_data_cv[, -which(names(train_data_cv) == "hypertension_type")]),
                                  label = train_data_cv$hypertension_type)
  valid_matrix_cv <- xgb.DMatrix(data = as.matrix(valid_data_cv[, -which(names(valid_data_cv) == "hypertension_type")]),
                                  label = valid_data_cv$hypertension_type)

  # Training the XGBoost model
  cv_model <- xgb.train(
    params = params,
    data = train_matrix_cv,
    nrounds = best_nrounds, 
    watchlist = list(train = train_matrix_cv, valid = valid_matrix_cv),
    verbose = 0
  )

  # predictions on the validation set
  valid_predictions_cv <- predict(cv_model, valid_matrix_cv)
  valid_predicted_classes_cv <- ifelse(valid_predictions_cv > 0.5, 1, 0)

  # Evaluating performance metrics
  conf_matrix_cv <- confusionMatrix(
    factor(valid_predicted_classes_cv),
    factor(valid_data_cv$hypertension_type)
  )

  # Calculating the ROC and AUC
  roc_curve_cv <- roc(valid_data_cv$hypertension_type, valid_predictions_cv)
  auc_value_cv <- auc(roc_curve_cv)

  # Storing metrics for each fold
  cv_auc[i] <- auc_value_cv
  cv_accuracy[i] <- conf_matrix_cv$overall["Accuracy"]
  cv_sensitivity[i] <- conf_matrix_cv$byClass["Sensitivity"]
  cv_specificity[i] <- conf_matrix_cv$byClass["Specificity"]

  # Plotting the ROC curve for each fold
  plot(roc_curve_cv, main = paste("ROC Curve (Fold", i, "AUC =", round(auc_value_cv, 3), ")"))
}

# Summarize performance metrics in a table
cv_summary <- data.frame(
  Fold = 1:k,
  AUC = round(cv_auc, 4),
  Accuracy = round(cv_accuracy, 4),
  Sensitivity = round(cv_sensitivity, 4),
  Specificity = round(cv_specificity, 4)
)

# Print summary table for each fold
cat("\n--- Cross-Validation Results Summary ---\n")
print(cv_summary)

# Average performance across folds
cat("\n--- Average Performance Across Folds ---\n")
cat("Average AUC:", round(mean(cv_auc), 3), "\n")
cat("Average Accuracy:", round(mean(cv_accuracy), 3), "\n")
cat("Average Sensitivity:", round(mean(cv_sensitivity), 3), "\n")
cat("Average Specificity:", round(mean(cv_specificity), 3), "\n")

# Final Model Evaluation on Test Set
final_predictions <- predict(xgb_model, test_matrix)
final_predicted_classes <- ifelse(final_predictions > 0.5, 1, 0)

# Confusion matrix for final model on test set
final_conf_matrix <- confusionMatrix(factor(final_predicted_classes), factor(test_data$hypertension_type))
print(final_conf_matrix)

# ROC curve and AUC for test set
final_roc_curve <- roc(test_data$hypertension_type, final_predictions)
final_auc_value <- auc(final_roc_curve)

# Plotting ROC curve for test set
plot(final_roc_curve, main = paste("Test ROC Curve (AUC =", round(final_auc_value, 3), ")"))

# Displaying final test set performance metrics
cat("\n--- Final Model Performance on Test Set ---\n")
cat("Test AUC:", round(final_auc_value, 4), "\n")
cat("Test Accuracy:", round(final_conf_matrix$overall["Accuracy"], 4), "\n")
cat("Test Sensitivity:", round(final_conf_matrix$byClass["Sensitivity"], 4), "\n")
cat("Test Specificity:", round(final_conf_matrix$byClass["Specificity"], 4), "\n")

# Printing the confusion matrix table for the testing set
cat("\n--- Final Test Set Confusion Matrix ---\n")
print(final_conf_matrix$table)

# Confusion Matrix for the Overall Training Set (after Cross-Validation)
train_predictions_all <- predict(xgb_model, train_matrix)
train_predicted_classes_all <- ifelse(train_predictions_all > 0.5, 1, 0)

train_conf_matrix_all <- confusionMatrix(factor(train_predicted_classes_all), factor(train_data$hypertension_type))
cat("\n--- Overall Training Set Confusion Matrix (--\n")
print(train_conf_matrix_all$table)


```


```{r}
# Loading the necessary libraries
library(caret)
library(rpart)
library(rpart.plot)
library(pROC)

# Preparing the UndiagnosedHypertension variable as a factor
numeric_diagnosed$hypertension_type <- ifelse(numeric_diagnosed$hypertension_type == 1, 1, 0)
numeric_diagnosed$hypertension_type <- as.factor(numeric_diagnosed$hypertension_type)

# Checking class distribution
print("Class distribution in UndiagnosedHypertension:")
print(table(numeric_diagnosed$hypertension_type))

# Defining categorical variables
categorical_vars <- c("AgeGroup", "SmokingStatus", "AlcoholConsumption", "SelfReportedHealth", 
                      "Region", "RuralUrban", "Education", "Ethnicity", "AttitudeNHS", 
                      "SocioeconomicStatus", "Gender", "BMI", "RelationshipStatus")

# Ensuring categorical variables are treated as factors
numeric_diagnosed[categorical_vars] <- lapply(numeric_diagnosed[categorical_vars], as.factor)

# Setting up k-fold cross-validation
set.seed(123)
cv_folds <- createFolds(numeric_diagnosed$hypertension_type, k = 6, list = TRUE)

# Initializing vectors to store metrics for cross-validation
cv_accuracy <- numeric(6)
cv_sensitivity <- numeric(6)
cv_specificity <- numeric(6)
cv_auc <- numeric(6)

# Performing a 10-fold cross-validation
for (i in 1:6) {
  # Split data into training and validation sets for this fold
  train_data2 <- numeric_diagnosed[-cv_folds[[i]], ]
  valid_data <- numeric_diagnosed[cv_folds[[i]], ]
  
  # Building the Decision Tree model
  dt_model <- rpart(hypertension_type ~ AgeGroup + BMI + SmokingStatus + AlcoholConsumption + 
                    SelfReportedHealth + Region + RuralUrban + Education + 
                    Ethnicity + SocioeconomicStatus + AttitudeNHS + Gender + RelationshipStatus, 
                    data = train_data2, 
                    method = "class")
  
  # Predictions on the validation set
  predictions <- predict(dt_model, newdata = valid_data, type = "class")
  
  # Evaluating model performance using confusion matrix
  conf_matrix <- confusionMatrix(predictions, valid_data$hypertension_type)
  
  # Storing metrics for this fold
  cv_accuracy[i] <- conf_matrix$overall["Accuracy"]
  cv_sensitivity[i] <- conf_matrix$byClass["Sensitivity"]
  cv_specificity[i] <- conf_matrix$byClass["Specificity"]
  
  # Calculating AUC and ROC curve
  predicted_probs <- predict(dt_model, newdata = valid_data, type = "prob")[, 2]
  roc_curve <- roc(valid_data$hypertension_type, predicted_probs)
  cv_auc[i] <- auc(roc_curve)
  
  # Plotting ROC curve for this fold
  plot(roc_curve, main = paste("ROC Curve (Fold", i, "AUC =", round(cv_auc[i], 3), ")"))
}

# Calculating and printing average metrics across all folds
cat("\n--- Cross-Validation Results ---\n")
cat("Average Accuracy:", mean(cv_accuracy), "\n")
cat("Average Sensitivity:", mean(cv_sensitivity), "\n")
cat("Average Specificity:", mean(cv_specificity), "\n")
cat("Average AUC:", mean(cv_auc), "\n")

# Summary table for cross-validation metrics
cv_summary <- data.frame(
  Fold = 1:6,
  AUC = round(cv_auc, 4),
  Accuracy = round(cv_accuracy, 4),
  Sensitivity = round(cv_sensitivity, 4),
  Specificity = round(cv_specificity, 4)
)

cat("\n--- Cross-Validation Summary ---\n")
print(cv_summary)

# Final Decision Tree model on the entire dataset (training data)
final_dt_model <- rpart(hypertension_type ~ AgeGroup + BMI + SmokingStatus + AlcoholConsumption + 
                        SelfReportedHealth + Region + RuralUrban + Education + 
                        Ethnicity + SocioeconomicStatus + AttitudeNHS + Gender + RelationshipStatus, 
                        data = numeric_diagnosed, 
                        method = "class")

# The final Decision Tree
rpart.plot(final_dt_model, type = 1, extra = 1, main = "Final Decision Tree for Undiagnosed Hypertension")

# Evaluating the test set
set.seed(123)
train_index <- createDataPartition(numeric_diagnosed$hypertension_type, p = 0.8, list = FALSE)
train_data <- numeric_diagnosed[train_index, ]
test_data <- numeric_diagnosed[-train_index, ]

# Make final predictions on the test set
final_predictions <- predict(final_dt_model, newdata = test_data, type = "class")

# Confusion Matrix for the test set
test_conf_matrix <- confusionMatrix(final_predictions, test_data$hypertension_type)
cat("\nFinal Test Set Confusion Matrix:\n")
print(test_conf_matrix$table)

# Calculating AUC for the final model
final_predicted_probs <- predict(final_dt_model, newdata = test_data, type = "prob")[, 2]
test_roc_curve <- roc(test_data$hypertension_type, final_predicted_probs)
test_auc_value <- auc(test_roc_curve)

# Plotting final ROC curve for the test set
plot(test_roc_curve, main = paste("Final Test ROC Curve (AUC =", round(test_auc_value, 3), ")"))

# Printing final performance metrics
final_sensitivity <- test_conf_matrix$byClass["Sensitivity"]
final_specificity <- test_conf_matrix$byClass["Specificity"]
final_ppv <- test_conf_matrix$byClass["Pos Pred Value"]
final_npv <- test_conf_matrix$byClass["Neg Pred Value"]

cat("\nFinal Model Performance on Test Set:\n")
cat("Sensitivity:", final_sensitivity, "\n")
cat("Specificity:", final_specificity, "\n")
cat("Positive Predictive Value:", final_ppv, "\n")
cat("Negative Predictive Value:", final_npv, "\n")
cat("Test AUC:", test_auc_value, "\n")

# Confusion Matrix for the Overall Training Set
train_predictions_all <- predict(final_dt_model, newdata = train_data, type = "class")
train_conf_matrix_all <- confusionMatrix(train_predictions_all, train_data$hypertension_type)
cat("\nOverall Training Set Confusion Matrix:\n")
print(train_conf_matrix_all$table)

```



```{r}
#UNCONTROLLED

# Set seed for reproducibility
set.seed(123)

# Sampling 1760 rows from combined_uncontrolled where hypertension_type = 3 (uncontrolled)
sampled_uncontrolled <- combined_uncontrolled %>%
  filter(hypertension_type == 3) %>%
  sample_n(1760)

# Sampling 1760 rows from combined_uncontrolled where hypertension_type = 4 (without uncontrolled)
sampled_woutcontrolled <- combined_uncontrolled %>%
  filter(hypertension_type == 4) %>%
  sample_n(1760)

# Combining the two sampled datasets into a balanced dataset
balanced_uncontrolled_data <- bind_rows(sampled_uncontrolled, sampled_woutcontrolled)

# Verifying the structure and counts of the balanced dataset
print(table(balanced_uncontrolled_data$hypertension_type))  
head(balanced_uncontrolled_data)                            

write_xlsx(balanced_uncontrolled_data, "C:/Users/bibia/OneDrive/Masters Personal Project/balanced_uncontrolled_hypertension_data.xlsx")


```

```{r}
str(balanced_uncontrolled_data)
summary(balanced_uncontrolled_data)
table(balanced_uncontrolled_data$Education)
```
```{r}
#CHANGING THE UNCONTROLLED HYPERTENSION DATASET INTO NUMERIC


# Defining weights ensuring higher numbers represent better outcomes for those categories that need to be 
weights <- list(
  AgeGroup = c("16-24 years" = 7, "25-34 years" = 6, "35-44 years" = 5, "45-54 years" = 4, "55-64 years" = 3, "65-74 years" = 2, "75 years and over" = 1),
  SelfReportedHealth = c("Very good or good" = 3, "Fair" = 2, "Bad or very bad" = 1),
  BMI = c("Not overweight" = 3, "Overweight" = 2, "Obese" = 1),
  Region = c("North East" = 9, "North West" = 8, "South East" = 7, "South West" = 6, "East Midlands" = 5, "West Midlands" = 4, "Yorkshire and the Humber" = 3, "East England" = 2, "London" = 1),
  RuralUrban = c("Urban" = 2, "Rural" = 1),
  RelationshipStatus = c("Single" = 1, "Married or civil partnership" = 5, "Cohabiting" = 4, "Separated or divorced" = 2, "Widowed or surviving partner" = 3),
  Education = c("Degree or equivalent qualification" = 3, "Below degree qualification" = 2, "No qualification" = 1),
  Ethnicity = c("White" = 4, "Black" = 3, "Asian" = 2, "Other" = 1),
  SocioeconomicStatus = c("Managerial and professional occupations" = 5, "Intermediate occupations" = 4, "Small employers and own account workers" = 3, "Lower supervisory and technical occupations" = 2, "Semi-routine occupations" = 1, "Other" = 0),
  SmokingStatus = c("Never regular cigarette smoker" = 3, "Ex-regular cigarette smoker" = 2, "Current cigarette smoker" = 1),
  AlcoholConsumption = c("Not at all in last 12 months/Non-drinker" = 8, "Once or twice a year" = 7, "Once every couple of months" = 6, "Once or twice a month" = 5, "Once or twice a week" = 4, "3 or 4 days a week" = 3, "5 or 6 days a week" = 2, "Almost every day" = 1),
  AttitudeNHS = c("Very satisfied" = 5, "Quite satisfied" = 4, "Neither satisfied or dissatisfied" = 3, "Quite dissatisfied" = 2, "Very dissatisfied" = 1),
  Gender = c("Female" = 2, "Male" = 1)
)


# Applying weights to convert categorical variables into interger
numeric_controlled <- balanced_uncontrolled_data %>%
  mutate(
    AgeGroup = recode(AgeGroup, !!!weights$AgeGroup),
    SelfReportedHealth = recode(SelfReportedHealth, !!!weights$SelfReportedHealth),
    BMI = recode(BMI, !!!weights$BMI),
    Region = recode(Region, !!!weights$Region),
    RuralUrban = recode(RuralUrban, !!!weights$RuralUrban),
    RelationshipStatus = recode(RelationshipStatus, !!!weights$RelationshipStatus),
    Education = recode(Education, !!!weights$Education),
    Ethnicity = recode(Ethnicity, !!!weights$Ethnicity),
    SocioeconomicStatus = recode(SocioeconomicStatus, !!!weights$SocioeconomicStatus),
    SmokingStatus = recode(SmokingStatus, !!!weights$SmokingStatus),
    AlcoholConsumption = recode(AlcoholConsumption, !!!weights$AlcoholConsumption),
    AttitudeNHS = recode(AttitudeNHS, !!!weights$AttitudeNHS),
    Gender = recode(Gender, !!!weights$Gender)
  )



str(numeric_controlled)
head(numeric_controlled)
nrow(numeric_controlled)

table(numeric_controlled$hypertension_type)
```


```{r}
# Ensuring categorical variables are treated as factors
categorical_vars <- c("AgeGroup", "SmokingStatus", "AlcoholConsumption", "SelfReportedHealth", 
                      "Region", "RuralUrban", "Education", "Ethnicity", "AttitudeNHS", 
                      "SocioeconomicStatus", "BMI", "RelationshipStatus", "Gender")
balanced_uncontrolled_data[categorical_vars] <- lapply(balanced_uncontrolled_data[categorical_vars], as.factor)

# Converting hypertension_type to a binary factor 3 for uncontrolled hypertension
balanced_uncontrolled_data$hypertension_type <- as.factor(ifelse(balanced_uncontrolled_data$hypertension_type == 3, 1, 0))
print("Class distribution in Hypertension type:")
print(table(balanced_uncontrolled_data$hypertension_type))

# Splitting data into training and testing sets
set.seed(123)
train_index <- createDataPartition(balanced_uncontrolled_data$hypertension_type, p = 0.8, list = FALSE)
train_data <- balanced_uncontrolled_data[train_index, ]
test_data <- balanced_uncontrolled_data[-train_index, ]

print("Class distribution in training set:")
print(table(train_data$hypertension_type))
print("Class distribution in testing set:")
print(table(test_data$hypertension_type))

# Setting up cross-validation folds
set.seed(123)
cv_folds <- createFolds(balanced_uncontrolled_data$hypertension_type, k = 6, list = TRUE, returnTrain = FALSE)

# Initializing vectors to store cross-validation metrics
cv_accuracy <- numeric(6)
cv_sensitivity <- numeric(6)
cv_specificity <- numeric(6)
cv_auc <- numeric(6)

# Performing a 6-fold cross-validation
for (i in 1:6) {
  # Splitting data into training and validation sets
  train_data2 <- balanced_uncontrolled_data[-cv_folds[[i]], ]
  valid_data <- balanced_uncontrolled_data[cv_folds[[i]], ]
  
  # Building the Random Forest model
  rf_model <- randomForest(hypertension_type ~ AgeGroup + BMI + SmokingStatus + AlcoholConsumption + 
                           SelfReportedHealth + Region + RuralUrban + Education + 
                           Ethnicity + SocioeconomicStatus + AttitudeNHS + Gender + RelationshipStatus, 
                           data = train_data2, 
                           importance = TRUE, 
                           ntree = 500)
  
  # Predictions on the validation set
  predictions <- predict(rf_model, newdata = valid_data, type = "prob")[, 2]
  
  # Calculating ROC curve and AUC
  roc_curve <- roc(as.numeric(as.character(valid_data$hypertension_type)), predictions)
  auc_value <- auc(roc_curve)
  cv_auc[i] <- auc_value
  
  # Store metrics for the validation set
  valid_conf_matrix <- confusionMatrix(predict(rf_model, newdata = valid_data), valid_data$hypertension_type)
  
  cv_accuracy[i] <- valid_conf_matrix$overall["Accuracy"]
  cv_sensitivity[i] <- valid_conf_matrix$byClass["Sensitivity"]
  cv_specificity[i] <- valid_conf_matrix$byClass["Specificity"]
}

# Create a summary table for cross-validation results (AUC, Accuracy, Sensitivity, Specificity for each fold)
cv_summary <- data.frame(
  Fold = 1:6,
  AUC = round(cv_auc, 3),
  Accuracy = round(cv_accuracy, 3),
  Sensitivity = round(cv_sensitivity, 3),
  Specificity = round(cv_specificity, 3)
)

cat("\n--- Cross-Validation Results Summary ---\n")
print(cv_summary)

# Calculating average performance metrics across folds
cat("\n--- Average Performance Across Folds ---\n")
cat("Average AUC:", round(mean(cv_auc), 3), "\n")
cat("Average Accuracy:", round(mean(cv_accuracy), 3), "\n")
cat("Average Sensitivity:", round(mean(cv_sensitivity), 3), "\n")
cat("Average Specificity:", round(mean(cv_specificity), 3), "\n")

# Building the final Random Forest model on the entire training dataset
final_rf_model <- randomForest(hypertension_type ~ AgeGroup + BMI + SmokingStatus + AlcoholConsumption + 
                               SelfReportedHealth + Region + RuralUrban + Education + 
                               Ethnicity + SocioeconomicStatus + AttitudeNHS+ RelationshipStatus+ Gender, 
                               data = train_data, 
                               importance = TRUE, 
                               ntree = 500)

# Displaying final feature importance
final_importance_values <- importance(final_rf_model)
print("Final Feature Importance:")
print(final_importance_values)

# Visualizing final feature importance
varImpPlot(final_rf_model, main = "Final Variable Importance Plot")

# Testing the model on the independent test set
final_predictions <- predict(final_rf_model, newdata = test_data, type = "prob")[, 2]

# Calculating ROC curve and AUC for the test set
test_roc_curve <- roc(as.numeric(as.character(test_data$hypertension_type)), final_predictions)
test_auc_value <- auc(test_roc_curve)

# Plotting ROC curve for the test set
plot(test_roc_curve, main = paste("Test ROC Curve (AUC =", round(test_auc_value, 3), ")"))

# Generate Confusion Matrix for the test set
test_conf_matrix <- confusionMatrix(predict(final_rf_model, newdata = test_data), test_data$hypertension_type)
cat("\n--- Final Test Set Confusion Matrix ---\n")
print(test_conf_matrix)

# Calculating and displaying final performance metrics for the test set
test_sensitivity <- test_conf_matrix$byClass["Sensitivity"]
test_specificity <- test_conf_matrix$byClass["Specificity"]

cat("\n--- Final Model Performance on Test Set ---\n")
cat("Test AUC:", round(test_auc_value, 3), "\n")
cat("Test Accuracy:", round(test_conf_matrix$overall["Accuracy"], 3), "\n")
cat("Test Sensitivity:", round(test_sensitivity, 3), "\n")
cat("Test Specificity:", round(test_specificity, 3), "\n")

# Generating confusion matrix for the training set
train_predictions <- predict(final_rf_model, newdata = train_data, type = "prob")[, 2]
train_conf_matrix <- confusionMatrix(predict(final_rf_model, newdata = train_data), train_data$hypertension_type)
cat("\n--- Final Training Set Confusion Matrix ---\n")
print(train_conf_matrix)

# Calculating and displaying final performance metrics for the training set
train_sensitivity <- train_conf_matrix$byClass["Sensitivity"]
train_specificity <- train_conf_matrix$byClass["Specificity"]

cat("\n--- Final Model Performance on Training Set ---\n")
cat("Train Accuracy:", round(train_conf_matrix$overall["Accuracy"], 3), "\n")
cat("Train Sensitivity:", round(train_sensitivity, 3), "\n")
cat("Train Specificity:", round(train_specificity, 3), "\n")


```


```{r}
# Ensuring the outcome variable is binary
numeric_controlled$hypertension_type <- factor(ifelse(numeric_controlled$hypertension_type == 3, 1, 0))

# Removing rows with NA values only in the outcome variable
numeric_controlled <- numeric_controlled[!is.na(numeric_controlled$hypertension_type), ]

# Removing the `id` column to prevent it from being included in the model
numeric_controlled <- numeric_controlled[, !names(numeric_controlled) %in% "id"]

# Converting categorical variables to one-hot encoding (dummy variables)
dummies <- dummyVars(~ AgeGroup + SmokingStatus + AlcoholConsumption +
                     SelfReportedHealth + Region + RuralUrban +
                     Education + Ethnicity + AttitudeNHS + Gender+ SocioeconomicStatus+ BMI + RelationshipStatus,
                     data = numeric_controlled)

numeric_controlled_dummies <- predict(dummies, newdata = numeric_controlled)

# Combining dummy variables with numeric predictors
numeric_controlled <- cbind(
  numeric_controlled[, !names(numeric_controlled) %in% c("AgeGroup", "SmokingStatus",
                                                       "AlcoholConsumption", "SelfReportedHealth",
                                                       "Region", "RuralUrban", "Education",
                                                       "Ethnicity", "AttitudeNHS", "Gender", "SocioeconomicStatus", "BMI", "RelationshipStatus")],
  numeric_controlled_dummies
)

# Converting outcome variable to numeric for XGBoost
numeric_controlled$hypertension_type <- as.numeric(as.character(numeric_controlled$hypertension_type))

# Splitting the data into training and testing sets
set.seed(123)
train_index <- createDataPartition(numeric_controlled$hypertension_type, p = 0.8, list = FALSE)
train_data <- numeric_controlled[train_index, ]
test_data <- numeric_controlled[-train_index, ]

# Preparing data for XGBoost
train_matrix <- xgb.DMatrix(data = as.matrix(train_data[, -which(names(train_data) == "hypertension_type")]),
                             label = train_data$hypertension_type)
test_matrix <- xgb.DMatrix(data = as.matrix(test_data[, -which(names(test_data) == "hypertension_type")]),
                            label = test_data$hypertension_type)

# Defining parameters for XGBoost
params <- list(
  objective = "binary:logistic",
  eval_metric = "auc",
  max_depth = 4,           
  eta = 0.05,              
  gamma = 5,               
  subsample = 0.8,         
  colsample_bytree = 0.8,  
  scale_pos_weight = 5     
)

# Performing 5-fold Cross-Validation to determine optimal boosting rounds
cv_results <- xgb.cv(
  params = params,
  data = train_matrix,
  nfold = 6,
  nrounds = 100,
  early_stopping_rounds = 10,
  verbose = 1,
  metrics = "auc"
)

# Displaying the best iteration and AUC
best_nrounds <- cv_results$best_iteration
cat("Best iteration from CV:", best_nrounds, "\n")
cat("Best AUC from CV:", max(cv_results$evaluation_log$test_auc_mean), "\n")

# Training the final model using the optimal number of boosting rounds
xgb_model <- xgb.train(
  params = params,
  data = train_matrix,
  nrounds = best_nrounds,
  watchlist = list(train = train_matrix, test = test_matrix),
  early_stopping_rounds = 10,
  verbose = 0
)

# Setting up k-fold cross-validation
set.seed(123)
k <- 6  
folds <- createFolds(numeric_controlled$hypertension_type, k = k)

# Initializing vectors to store cross-validation results
cv_auc <- numeric(k)
cv_accuracy <- numeric(k)
cv_sensitivity <- numeric(k)
cv_specificity <- numeric(k)

# Performing k-fold cross-validation
for (i in seq_along(folds)) {
  # Splitting data into training and validation sets
  train_indices <- setdiff(seq_len(nrow(numeric_controlled)), folds[[i]])
  train_data_cv <- numeric_controlled[train_indices, ]
  valid_data_cv <- numeric_controlled[folds[[i]], ]

  # Preparing training and validation matrices for XGBoost
  train_matrix_cv <- xgb.DMatrix(data = as.matrix(train_data_cv[, -which(names(train_data_cv) == "hypertension_type")]),
                                  label = train_data_cv$hypertension_type)
  valid_matrix_cv <- xgb.DMatrix(data = as.matrix(valid_data_cv[, -which(names(valid_data_cv) == "hypertension_type")]),
                                  label = valid_data_cv$hypertension_type)

  # Training the XGBoost model
  cv_model <- xgb.train(
    params = params,
    data = train_matrix_cv,
    nrounds = best_nrounds,  
    watchlist = list(train = train_matrix_cv, valid = valid_matrix_cv),
    verbose = 0
  )

  # Prediction on the validation set
  valid_predictions_cv <- predict(cv_model, valid_matrix_cv)
  valid_predicted_classes_cv <- ifelse(valid_predictions_cv > 0.5, 1, 0)

  # Evaluating performance metrics
  conf_matrix_cv <- confusionMatrix(
    factor(valid_predicted_classes_cv),
    factor(valid_data_cv$hypertension_type)
  )

  # Calculating the ROC and AUC
  roc_curve_cv <- roc(valid_data_cv$hypertension_type, valid_predictions_cv)
  auc_value_cv <- auc(roc_curve_cv)

  # Store metrics
  cv_auc[i] <- auc_value_cv
  cv_accuracy[i] <- conf_matrix_cv$overall["Accuracy"]
  cv_sensitivity[i] <- conf_matrix_cv$byClass["Sensitivity"]
  cv_specificity[i] <- conf_matrix_cv$byClass["Specificity"]
}

# Create a summary table for cross-validation results (AUC, Accuracy, Sensitivity, Specificity for each fold)
cv_summary <- data.frame(
  Fold = 1:k,
  AUC = round(cv_auc, 4),
  Accuracy = round(cv_accuracy, 4),
  Sensitivity = round(cv_sensitivity, 4),
  Specificity = round(cv_specificity, 4)
)

cat("\n--- Cross-Validation Results Summary ---\n")
print(cv_summary)

# Calculating average performance across folds
cat("\n--- Average Performance Across Folds ---\n")
cat("Average AUC:", round(mean(cv_auc), 3), "\n")
cat("Average Accuracy:", round(mean(cv_accuracy), 3), "\n")
cat("Average Sensitivity:", round(mean(cv_sensitivity), 3), "\n")
cat("Average Specificity:", round(mean(cv_specificity), 3), "\n")

# Final Model Evaluation on Test Set
final_predictions <- predict(xgb_model, test_matrix)
final_predicted_classes <- ifelse(final_predictions > 0.5, 1, 0)

# Confusion matrix for test set
final_conf_matrix <- confusionMatrix(factor(final_predicted_classes), factor(test_data$hypertension_type))
cat("\n--- Final Test Set Confusion Matrix ---\n")
print(final_conf_matrix)

# ROC curve and AUC for test set
final_roc_curve <- roc(test_data$hypertension_type, final_predictions)
final_auc_value <- auc(final_roc_curve)

# Plotting ROC curve for test set
plot(final_roc_curve, main = paste("Test ROC Curve (AUC =", round(final_auc_value, 3), ")"))

# Displaying final test set performance metrics
cat("\n--- Final Model Performance on Test Set ---\n")
cat("Test Sensitivity:", final_conf_matrix$byClass["Sensitivity"], "\n")
cat("Test Specificity:", final_conf_matrix$byClass["Specificity"], "\n")
cat("Test AUC:", final_auc_value, "\n")

# Final Confusion Matrix for Training Set
train_predictions <- predict(xgb_model, train_matrix)
train_predicted_classes <- ifelse(train_predictions > 0.5, 1, 0)

train_conf_matrix <- confusionMatrix(factor(train_predicted_classes), factor(train_data$hypertension_type))
cat("\n--- Final Training Set Confusion Matrix ---\n")
print(train_conf_matrix)

# Displaying final training set performance metrics
cat("\n--- Final Model Performance on Training Set ---\n")
cat("Train Sensitivity:", train_conf_matrix$byClass["Sensitivity"], "\n")
cat("Train Specificity:", train_conf_matrix$byClass["Specificity"], "\n")

```




```{r}
# Loading necessary libraries
library(caret)
library(rpart)
library(rpart.plot)
library(pROC)

# Preparing the UncontrolledHypertension variable as a factor
numeric_controlled$hypertension_type <- ifelse(numeric_controlled$hypertension_type == 3, 1, 0)
numeric_controlled$hypertension_type <- as.factor(numeric_controlled$hypertension_type)

# Checking class distribution
print("Class distribution in UncontrolledHypertension:")
print(table(numeric_controlled$hypertension_type))

# Defining categorical variables
categorical_vars <- c("AgeGroup", "SmokingStatus", "AlcoholConsumption", "SelfReportedHealth", 
                      "Region", "RuralUrban", "Education", "Ethnicity", "AttitudeNHS", 
                      "SocioeconomicStatus", "Gender", "BMI", "RelationshipStatus")

# Ensuring categorical variables are treated as factors
numeric_controlled[categorical_vars] <- lapply(numeric_controlled[categorical_vars], as.factor)

# Setting up k-fold cross-validation
set.seed(123)
cv_folds <- createFolds(numeric_controlled$hypertension_type, k = 6, list = TRUE)

# Initializing vectors to store metrics for cross-validation
cv_accuracy <- numeric(6)
cv_sensitivity <- numeric(6)
cv_specificity <- numeric(6)
cv_auc <- numeric(6)

# Performing 10-fold cross-validation
for (i in 1:6) {
  # Split data into training and validation sets for this fold
  train_data2 <- numeric_controlled[-cv_folds[[i]], ]
  valid_data <- numeric_controlled[cv_folds[[i]], ]
  
  # Building the Decision Tree model
  dt_model <- rpart(hypertension_type ~ AgeGroup + BMI + SmokingStatus + AlcoholConsumption + 
                    SelfReportedHealth + Region + RuralUrban + Education + 
                    Ethnicity + SocioeconomicStatus + AttitudeNHS + Gender + RelationshipStatus, 
                    data = train_data2, 
                    method = "class")
  
  # Predictions on the validation set
  predictions <- predict(dt_model, newdata = valid_data, type = "class")
  
  # Evaluating model performance using confusion matrix
  conf_matrix <- confusionMatrix(predictions, valid_data$hypertension_type)
  
  # Storing metrics for this fold
  cv_accuracy[i] <- conf_matrix$overall["Accuracy"]
  cv_sensitivity[i] <- conf_matrix$byClass["Sensitivity"]
  cv_specificity[i] <- conf_matrix$byClass["Specificity"]
  
  # Calculating AUC and ROC curve
  predicted_probs <- predict(dt_model, newdata = valid_data, type = "prob")[, 2]
  roc_curve <- roc(valid_data$hypertension_type, predicted_probs)
  cv_auc[i] <- auc(roc_curve)
  
  # Plotting ROC curve for this fold
  plot(roc_curve, main = paste("ROC Curve (Fold", i, "AUC =", round(cv_auc[i], 3), ")"))
}

# Create a summary table for cross-validation results
cv_results <- data.frame(
  Fold = 1:6,
  AUC = cv_auc,
  Accuracy = cv_accuracy,
  Sensitivity = cv_sensitivity,
  Specificity = cv_specificity
)

# Print the summary table of metrics
print("\n--- Cross-Validation Results ---")
print(cv_results)

# Calculating and printing average metrics across all folds
cat("\n--- Average Cross-Validation Results ---\n")
cat("Average Accuracy:", mean(cv_accuracy), "\n")
cat("Average Sensitivity:", mean(cv_sensitivity), "\n")
cat("Average Specificity:", mean(cv_specificity), "\n")
cat("Average AUC:", mean(cv_auc), "\n")

# Final Decision Tree model on the entire dataset (training data)
final_dt_model <- rpart(hypertension_type ~ AgeGroup + BMI + SmokingStatus + AlcoholConsumption + 
                        SelfReportedHealth + Region + RuralUrban + Education + 
                        Ethnicity + SocioeconomicStatus + AttitudeNHS + Gender + RelationshipStatus, 
                        data = numeric_controlled, 
                        method = "class")

# Visualizing the final Decision Tree
rpart.plot(final_dt_model, type = 1, extra = 1, main = "Final Decision Tree for Uncontrolled Hypertension")

# Evaluating on the test set 
set.seed(123)
train_index <- createDataPartition(numeric_controlled$hypertension_type, p = 0.8, list = FALSE)
train_data <- numeric_controlled[train_index, ]
test_data <- numeric_controlled[-train_index, ]

# Making final predictions on the test set
final_predictions <- predict(final_dt_model, newdata = test_data, type = "class")

# Confusion Matrix for the test set
test_conf_matrix <- confusionMatrix(final_predictions, test_data$hypertension_type)
cat("\nFinal Test Set Confusion Matrix:\n")
print(test_conf_matrix)

# Calculating AUC for the final model
final_predicted_probs <- predict(final_dt_model, newdata = test_data, type = "prob")[, 2]
test_roc_curve <- roc(test_data$hypertension_type, final_predicted_probs)
test_auc_value <- auc(test_roc_curve)

# Plotting final ROC curve for the test set
plot(test_roc_curve, main = paste("Final Test ROC Curve (AUC =", round(test_auc_value, 3), ")"))

# Final performance metrics
final_sensitivity <- test_conf_matrix$byClass["Sensitivity"]
final_specificity <- test_conf_matrix$byClass["Specificity"]
final_ppv <- test_conf_matrix$byClass["Pos Pred Value"]
final_npv <- test_conf_matrix$byClass["Neg Pred Value"]

cat("\nFinal Model Performance on Test Set:\n")
cat("Sensitivity:", final_sensitivity, "\n")
cat("Specificity:", final_specificity, "\n")
cat("Positive Predictive Value:", final_ppv, "\n")
cat("Negative Predictive Value:", final_npv, "\n")
cat("Test AUC:", test_auc_value, "\n")
```

```{r}
#CHANGING THE UNCONTROLLED HYPERTENSION DATASET INTO NUMERIC


# Defining weights ensuring higher numbers represent better outcomes for those categories that need to be 
weights <- list(
  AgeGroup = c("16-24 years" = 7, "25-34 years" = 6, "35-44 years" = 5, "45-54 years" = 4, "55-64 years" = 3, "65-74 years" = 2, "75 years and over" = 1),
  SelfReportedHealth = c("Very good or good" = 3, "Fair" = 2, "Bad or very bad" = 1),
  BMI = c("Not overweight" = 3, "Overweight" = 2, "Obese" = 1),
  Region = c("North East" = 9, "North West" = 8, "South East" = 7, "South West" = 6, "East Midlands" = 5, "West Midlands" = 4, "Yorkshire and the Humber" = 3, "East England" = 2, "London" = 1),
  RuralUrban = c("Urban" = 2, "Rural" = 1),
  RelationshipStatus = c("Single" = 1, "Married or civil partnership" = 5, "Cohabiting" = 4, "Separated or divorced" = 2, "Widowed or surviving partner" = 3),
  Education = c("Degree or equivalent qualification" = 3, "Below degree qualification" = 2, "No qualification" = 1),
  Ethnicity = c("White" = 4, "Black" = 3, "Asian" = 2, "Other" = 1),
  SocioeconomicStatus = c("Managerial and professional occupations" = 5, "Intermediate occupations" = 4, "Small employers and own account workers" = 3, "Lower supervisory and technical occupations" = 2, "Semi-routine occupations" = 1, "Other" = 0),
  SmokingStatus = c("Never regular cigarette smoker" = 3, "Ex-regular cigarette smoker" = 2, "Current cigarette smoker" = 1),
  AlcoholConsumption = c("Not at all in last 12 months/Non-drinker" = 8, "Once or twice a year" = 7, "Once every couple of months" = 6, "Once or twice a month" = 5, "Once or twice a week" = 4, "3 or 4 days a week" = 3, "5 or 6 days a week" = 2, "Almost every day" = 1),
  AttitudeNHS = c("Very satisfied" = 5, "Quite satisfied" = 4, "Neither satisfied or dissatisfied" = 3, "Quite dissatisfied" = 2, "Very dissatisfied" = 1),
  Gender = c("Female" = 2, "Male" = 1)
)


# Applying weights to convert categorical variables into interger
numeric_controlled2 <- combined_uncontrolled %>%
  mutate(
    AgeGroup = recode(AgeGroup, !!!weights$AgeGroup),
    SelfReportedHealth = recode(SelfReportedHealth, !!!weights$SelfReportedHealth),
    BMI = recode(BMI, !!!weights$BMI),
    Region = recode(Region, !!!weights$Region),
    RuralUrban = recode(RuralUrban, !!!weights$RuralUrban),
    RelationshipStatus = recode(RelationshipStatus, !!!weights$RelationshipStatus),
    Education = recode(Education, !!!weights$Education),
    Ethnicity = recode(Ethnicity, !!!weights$Ethnicity),
    SocioeconomicStatus = recode(SocioeconomicStatus, !!!weights$SocioeconomicStatus),
    SmokingStatus = recode(SmokingStatus, !!!weights$SmokingStatus),
    AlcoholConsumption = recode(AlcoholConsumption, !!!weights$AlcoholConsumption),
    AttitudeNHS = recode(AttitudeNHS, !!!weights$AttitudeNHS),
    Gender = recode(Gender, !!!weights$Gender)
  )



str(numeric_controlled2)
head(numeric_controlled2)
nrow(numeric_controlled2)

table(numeric_controlled2$hypertension_type)

nrow(numeric_controlled2)



```
```{r}
nrow(numeric_controlled2)
```


```{r}
library(performance)
library(nortest)

# objective 4 - To find out how the people’s attitude towards NHS affects their health regarding to hypertension control.

# Assuming your data frame is named numeric_uncontrolled

# Converting hypertension type to a numeric variable for analysis
numeric_controlled <- numeric_controlled %>%
  mutate(hypertension_type = ifelse(hypertension_type == 3, 1, 0))  # 1 = uncontrolled, 0 = controlled

#summary of Atitude NHS
summary(numeric_controlled$AttitudeNHS)


# Fitting the linear regression model

model1 <- lm(numeric_controlled$hypertension_type~numeric_controlled$AttitudeNHS)  


# Summary of the regression model
summary(model1)

#checking the model
check_model(model1)

#normality test on the residuals

residuals_data <- residuals(model1)

ad.test(residuals_data)
```







```{r}
# objective 5 - to examine how socioeconomic status, smoking, alcohol consumption and people’s attitude towards NHS affect hypertension prevalence and management.

# Converting hypertension type to a numeric variable for analysis
numeric_controlled<- numeric_controlled %>%
  mutate(hypertension_type = ifelse(hypertension_type == 3, 1, 0))  # 1 = uncontrolled, 0 = controlled

# Fitting the regression model
multiple_linear_model <- lm(hypertension_type ~ SocioeconomicStatus + SmokingStatus + 
                             AlcoholConsumption + AttitudeNHS, 
                             data = numeric_controlled)

# Summary of the regression model
summary(multiple_linear_model)

#checking the model
check_model(multiple_linear_model)

#normality test on the residuals

residuals_data <- residuals(multiple_linear_model)

shapiro.test(residuals_data)
```

